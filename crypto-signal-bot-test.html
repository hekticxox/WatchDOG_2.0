<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Signal Bot - Algorithm Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 { text-align: center; margin-bottom: 30px; }
        .section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        .features, .breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .feature, .breakdown-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .result {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        .success { background: rgba(76, 175, 80, 0.3); }
        .warning { background: rgba(255, 193, 7, 0.3); }
        .prediction {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        button:hover { background: #45a049; }
        .emoji { font-size: 24px; }
    </style>
</head>
<body>
    <div class="container">
        <h1><span class="emoji">??</span> Crypto Signal Bot Algorithm Test</h1>
        
        <div class="section">
            <h2><span class="emoji">??</span> Input Features</h2>
            <div id="features" class="features"></div>
            <p><strong>Card Count:</strong> <span id="cardCount">+5</span> (from previous predictions)</p>
        </div>

        <div class="section">
            <h2><span class="emoji">??</span> Scoring Results</h2>
            <div id="results"></div>
        </div>

        <div class="section">
            <h2><span class="emoji">??</span> Score Breakdown</h2>
            <div id="breakdown" class="breakdown"></div>
        </div>

        <div class="section">
            <h2><span class="emoji">??</span> Prediction Decision</h2>
            <div id="decision"></div>
        </div>

        <div id="prediction" style="display: none;"></div>

        <div style="text-align: center; margin-top: 30px;">
            <button onclick="runTest()">?? Run New Test</button>
            <button onclick="runRandomTest()">?? Random Market Scenario</button>
        </div>
    </div>

    <script>
        // Mock features for testing
        const mockScenarios = [
            {
                name: "Strong Bull Signal",
                features: [
                    { name: 'RSI', timeframe: '1h', direction: 'long', weight: 1.0, strength: 0.8 },
                    { name: 'MACD', timeframe: '1h', direction: 'long', weight: 1.2, strength: 0.7 },
                    { name: 'EMA_20', timeframe: '1h', direction: 'long', weight: 0.8, strength: 0.6 },
                    { name: 'RSI', timeframe: '4h', direction: 'long', weight: 1.0, strength: 0.9 },
                    { name: 'BB', timeframe: '4h', direction: 'long', weight: 1.0, strength: 0.5 },
                    { name: 'VOLUME', timeframe: '1h', direction: 'long', weight: 0.7, strength: 0.8 }
                ],
                cardCount: 5
            },
            {
                name: "Bear Market Signal",
                features: [
                    { name: 'RSI', timeframe: '1h', direction: 'short', weight: 1.0, strength: 0.9 },
                    { name: 'MACD', timeframe: '2h', direction: 'short', weight: 1.2, strength: 0.8 },
                    { name: 'EMA_20', timeframe: '4h', direction: 'short', weight: 0.8, strength: 0.7 },
                    { name: 'STOCH', timeframe: '1h', direction: 'short', weight: 0.9, strength: 0.6 }
                ],
                cardCount: -3
            },
            {
                name: "Weak Signal (Won't Create Prediction)",
                features: [
                    { name: 'RSI', timeframe: '5m', direction: 'long', weight: 1.0, strength: 0.3 },
                    { name: 'EMA_20', timeframe: '15m', direction: 'short', weight: 0.8, strength: 0.2 }
                ],
                cardCount: 1
            }
        ];

        let currentScenario = 0;

        // Scoring algorithm (same as your backend)
        function computeScore(features, cardCount) {
            const breakdown = {};
            let score = 0;
            let indicatorCount = 0;

            // Basic scoring
            for (const f of features) {
                const base = (f.weight || 1) * (f.strength || 1);
                const key = `${f.name}_${f.timeframe}_${f.direction}`;
                breakdown[key] = (breakdown[key] || 0) + base;
                
                if (f.direction === 'long') score += base;
                else if (f.direction === 'short') score -= base;
                if (f.direction) indicatorCount++;
            }

            // Co-occurrence bonus
            const tfDirCounts = {};
            for (const k of Object.keys(breakdown)) {
                const parts = k.split('_');
                const tf = parts[1], dir = parts[2];
                const k2 = `${tf}_${dir}`;
                tfDirCounts[k2] = (tfDirCounts[k2] || 0) + 1;
            }
            
            for (const k in tfDirCounts) {
                if (tfDirCounts[k] >= 3) {
                    score += (tfDirCounts[k] - 2) * 0.5 * (k.endsWith('long') ? 1 : -1);
                }
            }

            // Card count bonus
            score += cardCount * 0.2;

            return { score, indicatorCount, breakdown };
        }

        function estimateRunDuration(score, timeframesAgreement) {
            const base = 30;
            const extra = Math.min(Math.max(score * 10, 0), 210);
            const hf = timeframesAgreement.filter(t => ['1h','2h','4h'].includes(t)).length;
            const hfBonus = hf * 30;
            const total = Math.min(240, base + extra + hfBonus);
            return total * 60 * 1000; // ms
        }

        function calculateConfidence(score, indicatorCount, features) {
            const baseConfidence = Math.min(Math.abs(score) * 6, 50);
            const indicatorBonus = Math.min(indicatorCount * 1.2, 12);
            const strengthBonus = features.reduce((sum, f) => sum + f.strength, 0) / features.length * 8;
            const confidence = Math.min(baseConfidence + indicatorBonus + strengthBonus + 15, 92);
            return confidence;
        }

        function runTest() {
            const scenario = mockScenarios[currentScenario % mockScenarios.length];
            displayTest(scenario);
            currentScenario++;
        }

        function runRandomTest() {
            const randomScenario = mockScenarios[Math.floor(Math.random() * mockScenarios.length)];
            displayTest(randomScenario);
        }

        function displayTest(scenario) {
            // Display features
            const featuresDiv = document.getElementById('features');
            featuresDiv.innerHTML = scenario.features.map((f, i) => 
                `<div class="feature">
                    <strong>${f.name}</strong> (${f.timeframe})<br>
                    Direction: <span style="color: ${f.direction === 'long' ? '#4CAF50' : '#f44336'}">${f.direction}</span><br>
                    Strength: ${f.strength}
                </div>`
            ).join('');

            document.getElementById('cardCount').textContent = scenario.cardCount > 0 ? `+${scenario.cardCount}` : scenario.cardCount;

            // Calculate results
            const result = computeScore(scenario.features, scenario.cardCount);
            const direction = result.score > 0 ? 'LONG' : 'SHORT';
            const agreementTimeframes = scenario.features
                .filter(f => f.direction === direction.toLowerCase())
                .map(f => f.timeframe)
                .filter((v, i, a) => a.indexOf(v) === i);
            
            const duration = estimateRunDuration(Math.abs(result.score), agreementTimeframes);
            const durationMins = Math.round(duration / (1000 * 60));
            const confidence = calculateConfidence(result.score, result.indicatorCount, scenario.features);

            // Display results
            document.getElementById('results').innerHTML = `
                <div class="result ${Math.abs(result.score) >= 2 ? 'success' : 'warning'}">
                    <div><strong>Scenario:</strong> ${scenario.name}</div>
                    <div><strong>Total Score:</strong> ${result.score.toFixed(2)}</div>
                    <div><strong>Direction:</strong> ${direction}</div>
                    <div><strong>Indicator Count:</strong> ${result.indicatorCount}</div>
                    <div><strong>Estimated Duration:</strong> ${durationMins} minutes</div>
                    <div><strong>Confidence:</strong> ${confidence.toFixed(1)}%</div>
                </div>
            `;

            // Display breakdown
            const breakdownDiv = document.getElementById('breakdown');
            breakdownDiv.innerHTML = Object.entries(result.breakdown)
                .map(([key, value]) => 
                    `<div class="breakdown-item">
                        <strong>${key}:</strong> ${value.toFixed(2)} points
                    </div>`
                ).join('');

            // Decision logic
            const minScore = 2.0;
            const minDuration = 30 * 60 * 1000;
            const maxDuration = 4 * 60 * 60 * 1000;
            const minConfidence = 40;

            const scorePass = Math.abs(result.score) >= minScore;
            const durationPass = duration >= minDuration && duration <= maxDuration;
            const confidencePass = confidence >= minConfidence;

            document.getElementById('decision').innerHTML = `
                <div class="result">
                    <div>Score ? ${minScore}? ${scorePass ? '?' : '?'} (${Math.abs(result.score).toFixed(2)})</div>
                    <div>Duration 30m-4h? ${durationPass ? '?' : '?'} (${durationMins}min)</div>
                    <div>Confidence ? ${minConfidence}%? ${confidencePass ? '?' : '?'} (${confidence.toFixed(1)}%)</div>
                </div>
            `;

            const wouldCreate = scorePass && durationPass && confidencePass;
            const predictionDiv = document.getElementById('prediction');

            if (wouldCreate) {
                predictionDiv.style.display = 'block';
                predictionDiv.className = 'prediction';
                predictionDiv.innerHTML = `
                    <div class="emoji">??</div>
                    <div>PREDICTION WOULD BE CREATED!</div>
                    <div style="margin-top: 15px; font-size: 16px;">
                        <div><strong>Symbol:</strong> BTCUSDT (example)</div>
                        <div><strong>Direction:</strong> ${direction}</div>
                        <div><strong>Confidence:</strong> ${confidence.toFixed(1)}%</div>
                        <div><strong>Duration:</strong> ${durationMins} minutes</div>
                        <div><strong>Score:</strong> ${result.score.toFixed(2)}</div>
                    </div>
                `;
            } else {
                predictionDiv.style.display = 'block';
                predictionDiv.className = 'result warning';
                predictionDiv.innerHTML = `
                    <div class="emoji">?</div>
                    <div>Prediction criteria not met</div>
                `;
            }
        }

        // Run initial test
        runTest();
    </script>
</body>
</html>